#!/usr/bin/env python3

import argparse
import json
import sys
from lib.json_report import JsonReport
from lib.report import Report
from lib.logging import log, select_loglevel
from lib.classify import Classification

PROGRAM_VERSION = "0.1.0"


def arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser()
    parser.add_argument("--version", action="version", version=f"%(prog)s {PROGRAM_VERSION}")
    parser.add_argument(
        "--verbose",
        "-v",
        action="count",
        default=0,
        help="""
        increase output verbosity
        """,
    )

    subparsers = parser.add_subparsers()
    arg_parser_collect(subparsers)
    arg_parser_classify(subparsers)

    return parser


def arg_parser_collect(subparsers) -> None:
    parser = subparsers.add_parser(
        "collect",
        help="""
        collect all issues of a log file generated by PTXdist and convert into JSON supported by Jenkins\' Warnings NG plugin.
        """,
    )
    parser.set_defaults(func=collect)
    parser.add_argument(
        "infile",
        nargs="?",
        type=argparse.FileType("r", encoding="UTF-8", errors="ignore"),
        default=sys.stdin,
        help="""
        name of the logfile. (default: stdin)
        """,
    )
    parser.add_argument(
        "outfile",
        nargs="?",
        type=argparse.FileType("w"),
        default=sys.stdout,
        help="""
        name of the file receiving the collected issues. (default: stdout)
        """,
    )

    parser.add_argument(
        "--resolvefolder",
        default=".",
        help="""
        paths inside the generated issues will be relative to this folder, e.g. test-workspace
        """,
    )
    parser.add_argument(
        "--buildfolder",
        default=".",
        help="""
        path to where the build has run, e.g. test-workspace/pfc
        """,
    )
    parser.add_argument(
        "--pathmap",
        default='{ "/workspace/pfc/": "", "platform-":"ptxproj/platform-" }',
        help="""
        a map describing mappings of paths. (JSON string, default: '{ \"/workspace/pfc/\": \"\", \"platform-\":\"ptxproj/platform-\" }')
        """,
    )
    parser.add_argument(
        "--additional_pathmap",
        action="extend",
        nargs="+",
        type=str,
        help="""
        map(s) describing mappings of paths (JSON string). will be appended to pathmap
        """,
    )
    parser.add_argument(
        "--defaultmodule",
        default="",
        help="""
        name of module if not described in logfile
        """,
    )
    parser.set_defaults(multiline=False)
    parser.add_argument(
        "--multiline",
        action="store_true",
        help="""
        enable parsing of multiline warnings
        """,
    )


def arg_parser_classify(subparsers) -> None:
    parser = subparsers.add_parser(
        "classify",
        help="""
        split issues within a JSON file according to rules in a mapping table.
        """,
    )
    parser.set_defaults(func=classify)
    parser.add_argument(
        "--input",
        default=".",
        required=True,
        help="""
        path to json file containing issues
        """,
    )
    parser.add_argument(
        "--output",
        default=".",
        required=True,
        help="""
        path to folder receiving the separeated json files
        """,
    )
    parser.add_argument(
        "--csv",
        default=".",
        help="""
        path to csv file containing classification information
        """,
    )
    parser.add_argument(
        "--module_name_column",
        type=int,
        default=0,
        help="""
        index of column in table containing module name
        """,
    )
    parser.add_argument(
        "--classification_column",
        type=int,
        default=0,
        help="""
        index of column in table containing classification
        """,
    )


def collect(arguments) -> None:
    log(f"Parsing '{arguments.infile.name}'", verbose=1)
    mappings = json.loads(arguments.pathmap)
    for mapping in arguments.additional_pathmap or []:
        mappings.update(json.loads(mapping))

    report = Report(
        build_folder=arguments.buildfolder,
        work_folder=arguments.resolvefolder,
        default_module=arguments.defaultmodule,
        mappings=mappings,
        multiline=arguments.multiline,
    )
    issues = report.process_file(arguments.infile)
    log(f"Found {len(issues)} issues.", verbose=1)
    log(f"Writing JSON to '{arguments.outfile.name}'", verbose=1)
    JsonReport.write_to_json(issues, arguments.outfile)


def classify(arguments) -> None:
    classification = Classification().get_classification_from_csv(
        file_name=arguments.csv,
        module_name_column=arguments.module_name_column,
        classification_column=arguments.classification_column,
    )
    issues = JsonReport.read_from_json(arguments.input)
    classified = classification.group_issues(issues)
    for group, issues in classified.items():
        group_name = arguments.output + "/" + group + ".json"
        with open(file=group_name, mode="w", encoding="UTF-8") as handle:
            JsonReport.write_to_json(set(issues), handle)


def main() -> None:
    argparser = arg_parser()
    args = argparser.parse_args()
    if "func" not in args:
        argparser.print_help()
        sys.exit(1)
    select_loglevel(args.verbose)
    args.func(args)


if __name__ == "__main__":
    main()
